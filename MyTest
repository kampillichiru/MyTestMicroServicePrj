<dependency>
    <groupId>jakarta.xml.bind</groupId>
    <artifactId>jakarta.xml.bind-api</artifactId>
    <version>3.0.1</version>
</dependency>
<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
    <version>3.0.1</version>
</dependency>
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import org.springframework.core.io.ClassPathResource;

import javax.xml.XMLConstants;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import java.io.InputStream;
import java.io.StringReader;

public class XmlProcessor {

    private final XmlMapper xmlMapper;
    private final Schema schema;

    public XmlProcessor(String xsdPath) throws Exception {
        this.xmlMapper = new XmlMapper();

        // Load XSD schema during initialization for reuse
        try (InputStream xsdStream = new ClassPathResource(xsdPath).getInputStream()) {
            SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
            this.schema = factory.newSchema(new StreamSource(xsdStream));
        }
    }

    public <T> T processXml(String xml, Class<T> targetType) throws Exception {
        // Step 1: Validate XML against the schema
        validateXml(xml);

        // Step 2: Deserialize XML to Java Object
        return xmlMapper.readValue(xml, targetType);
    }

    private void validateXml(String xml) throws Exception {
        try (var reader = new StringReader(xml)) {
            var validator = schema.newValidator();
            validator.validate(new StreamSource(reader));
        }
    }
}
