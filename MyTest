import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@Configuration
public class ThreadPoolConfig {
    int corePoolSize = Runtime.getRuntime().availableProcessors(); // Dynamic based on CPUs
    int maxPoolSize = corePoolSize * 2; // Allow double threads for scaling
    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(corePoolSize);
        executor.setMaxPoolSize(maxPoolSize);
        executor.setQueueCapacity(calculateQueueCapacity());
        executor.setThreadNamePrefix("AggregatorThread-");
        executor.initialize();
        return executor;
    }

    private int calculateQueueCapacity() {
        long totalMemory = Runtime.getRuntime().maxMemory();
        long availableMemoryForQueue = (long) (totalMemory * 0.7); // Reserve 30% memory
        long memoryPerTask = 1024 * 1024; // 1MB per task
        int memoryBasedQueueCapacity = (int) (availableMemoryForQueue / memoryPerTask);

        int cpuBasedCapacity = Runtime.getRuntime().availableProcessors() * 10; // CPU-based scaling
        return Math.min(memoryBasedQueueCapacity, cpuBasedCapacity);
    }
}
