Got it âœ…
Since youâ€™re using **`argo-githubactions-appset`** as the GitOps repo folder structure, Iâ€™ll prepare a **ready-to-use SecretProviderClass Helm template** that fits into your setup and is **easy to configure per environment**.

---

## ðŸ“‚ GitOps Folder Structure (with Key Vault support)

```
argo-githubactions-appset/
â”œâ”€ .github/workflows/
â”‚  â”œâ”€ update-gitops.yaml               # reusable workflow
â”‚  â”œâ”€ deploy-microservice-1.yaml
â”‚  â”œâ”€ deploy-microservice-2.yaml
â”œâ”€ gitops/
â”‚  â”œâ”€ argo-appset.yaml                 # ApplicationSet definition
â”‚  â”œâ”€ charts/app/                      # Reusable Helm chart
â”‚  â”‚  â”œâ”€ templates/
â”‚  â”‚  â”‚  â”œâ”€ deployment.yaml
â”‚  â”‚  â”‚  â”œâ”€ service.yaml
â”‚  â”‚  â”‚  â”œâ”€ secretproviderclass.yaml   # <-- CSI driver integration
â”‚  â”‚  â””â”€ values.yaml
â”‚  â””â”€ microservices/
â”‚     â””â”€ microservice-1/
â”‚        â”œâ”€ dev/values.yaml
â”‚        â”œâ”€ tst/values.yaml
â”‚        â”œâ”€ uat/values.yaml
â”‚        â””â”€ prod/values.yaml
```

---

## ðŸ›  `charts/app/templates/secretproviderclass.yaml`

```yaml
{{- if .Values.azureKeyVault.enabled }}
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: {{ include "app.fullname" . }}-akv
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"  # if using managed identity set this true
    useVMManagedIdentity: "true"
    userAssignedIdentityID: {{ .Values.azureKeyVault.userAssignedIdentityID | quote }}
    keyvaultName: {{ .Values.azureKeyVault.name | quote }}
    cloudName: "" # AzureCloud, AzureUSGovernment, AzureChinaCloud
    objects: |
      array:
        - |
          objectName: {{ .Values.azureKeyVault.secretName }}
          objectType: secret
    tenantId: {{ .Values.azureKeyVault.tenantId | quote }}
{{- end }}
```

---

## âš™ï¸ Example `values.yaml` per Environment

### `gitops/microservices/microservice-1/dev/values.yaml`

```yaml
image:
  repository: myacr.azurecr.io/microservice-1
  tag: dev-latest

azureKeyVault:
  enabled: true
  name: my-dev-keyvault
  tenantId: "00000000-0000-0000-0000-000000000000"
  userAssignedIdentityID: "11111111-1111-1111-1111-111111111111"
  secretName: "db-connection-string"
```

### `gitops/microservices/microservice-1/prod/values.yaml`

```yaml
image:
  repository: myacr.azurecr.io/microservice-1
  tag: prod-latest

azureKeyVault:
  enabled: true
  name: my-prod-keyvault
  tenantId: "00000000-0000-0000-0000-000000000000"
  userAssignedIdentityID: "22222222-2222-2222-2222-222222222222"
  secretName: "db-connection-string"
```

---

## ðŸ”„ Flow with ArgoCD

1. GitHub Action updates **image.tag** in `values.yaml` of a microservice/environment.
2. ArgoCD syncs â†’ renders Helm â†’ deploys app **+ SecretProviderClass**.
3. CSI driver mounts Key Vault secret at pod runtime.
4. Deployment reads secrets from volume or env var.

---

## âœ… Advantages

* **Reusable**: only update `values.yaml` per environment.
* **Automated**: GitHub Actions just commits to repo, ArgoCD applies.
* **Secure**: no secrets in GitHub Actions, all come from Key Vault at runtime.

---

ðŸ‘‰ Do you also want me to include an **example Deployment manifest** (with secret volume mount + env var) that uses the Key Vault secret, so your pods actually consume it?
